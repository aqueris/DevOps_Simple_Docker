### Небольшое предисловие.
_В данном "гайде" собран минимум знаний и команд, чтобы просто не потеряться в докере, а так же понять как с ним работать, этого недостаточно, чтобы прозвать себя великим знатоком докера, но более чем достаточно для комфортной работы, так же можно заглянуть за "техническими примерами" в /src/some_tips.md._

## Глава 1. Базовые команды.

#### Часть 1. Перечень базовых команд, необходимых для создания "первого" контейнера:

- **`docker pull image_name`** - позволяет загрузить необходимый образ для создания контейнера, например **docker pull nginx** скачает образ последней версии **nginx** для дальнейшей работы с ним.
- **`docker images`** - позволяет посмотреть все готовые для работы образы
- **`docker run image_name`** - создаёт и запускает контейнер с выбранным образом.

***Опционально. Полезные флаги `docker run`***

> **`docker run image_name command_to_run (command_arguments)`** - запуск с выполнением команды.
>
> **`docker run -d image_name`** - запуск в фоновом режиме.
>
> **`docker run -it image_name`** - запуск в инетарктивном режиме.
>
> **`docker run --rm image_name`** - запустит контейнер, который автоматически удалится после завершения работы.
>
> **`docker run --name image_name`** - указывает своё имя для **контейнера**.
>
> **`docker run image_name:image_version`** - запуск определённой версии образа.
>
> Чтобы выйти из интерактивного режима - воспользуйтесь сочетанием клавиш ***ctrl+D***.

- **`docker rmi image_name`** - позволяет удалить более ненужный образ. Если у образа есть тег(и), то есть 2 варианта:
    1. Удаление тег(а/ов) с последующим удалением образа:
    `docker rmi image_name:tag`
    `docker rmi image_name`
    2. "_Волшебный_" флаг -f (--force) - принудительное удаление образа.
    `docker rmi -f image_name`
- **`docker ps`** - (_советую использовать с флагом_ ***-а***) - позволяет посмотреть запущенные контейнеры, а флаг **-а** позволяет увидеть все контейнеры в целом.
- **`docker start container_name/container_id`** - запускает уже существующий контейнер.
- **`docker stop container_name/container_id`** - останавливает(выключает) работающий контейнер, ожидая завершения внутренних процессов. При слишком большом времени ожидания (по умолчанию 10 секунд, можно увеличить при помощи флага **-t**), докер автоматически выполняет **docker kill** на этом контейнере.
- **`docker kill container_name/container_id`** - принудительное выключение контейнера. По сути то же самое что **docker stop**, но в этом случае контейнер выключается мгновенно, не отправляя сигналов родительским процессам о своём завершении, так же обрывая все внутренние процессы.
- **`docker pause container_name/container_id`** - позволяет "поставить на паузу" работающий контейнер - по сути контейнер не останавливается, но и не выполняет никаких функций.
- **`docker unpause container_name/container_id`** - возобновляет работу приостановленного паузой контейнера.
- **`docker rm container_name/container_id`** - позволяет удалить ненужный контейнер.

***Дополнительно. Если вы хотите снести вообще всё:***

> **`docker system prune -a --volumes`** - удаляет все неиспользуемые контейнеры и образы. Флаг **-a** позволяет удалить неиспользуемые образы, а флаг **-volumes** позволяет удалить все связанные и неиспользуемые тома. Чтобы ***снести всё*** - сначала остановите все контейнеры.

#### Часть 2. Перечень базовых команд, необходимых для работы с контейнером:

- **`docker inspect container_name/container_id`** - позволяет увидеть содержимое контейнера. (Рекомендую использовать в сочетании с **| grep**).
- **`docker stats container_name/container_id`** - показывает используемые контейнером ресурсы.
- **`docker logs container_name/container_id`** - показывает логи контейнера. Можно использовать флаг **-f** для просмотра логов в _live_ режиме.
- **`docker exec container_name/container_id command (command_arguments)`** - позволяет выполнить команду внутри запущенного контейнера.

***Опционально. Полезные флаги `docker exec`***

> **`docker exec -d ...`** - позволяет выполнить команду в фоновом режиме.
>
> **`docker exec -it ...`** - позволяет выполнить команду с переходом в интерактивный режим.
>
> Чтобы выйти из интерактивного режима - воспользуйтесь сочетанием клавиш ***ctrl+D***.

## Глава 2. Управление портами.

- **`docker run -p server_port:container_port image_name`** - позволяет запустить контейнер с проброшенными портами.

- Можно пробрасывать несколько портов за раз, просто используйте флаг **-p** столько раз, сколько портов нужно пробросить.

Для предоставления доступа в контейнер извне, необходимо "пробрасывать" порты. Таким образом, команда **`docker run -p server_port:container_port image_name`** запустит контейнер, в котором трафик с порта сервера - **server_port** будет перенаправляться в порт работающего контейнера - **container_port**.

Чтобы было немного понятнее, объясню на примере:

- Возьмём за пример образ с nginx. Создадим и запустим контейнер **без** прокидывания портов и посмотрим что из этого выйдет.
![](./src/screenshots/docker%20closed%20ports.png "Запущенный контейнер с nginx без маппинга портов.")
- Контейнер работает - попробуем зайти на локалхост и проверить nginx.
![](./src/screenshots/docker%20closed%20ports%202.png "Отображение страницы с nginx.")
- Как итог - мы не можем подключиться к контейнеру и посмотреть приветствие от nginx.

Попытка не увенчалась успехом.

- Теперь попробуем сделать всё "правильно". Повторяем предыдущие шаги, но теперь обязательно прокидываем порты с рабочей машины в контейнер.
![](./src/screenshots/docker%20open%20ports.png "Запущенный контейнер с замапленными портами") 
- Проверяем страницу с nginx
![](./src/screenshots/docker%20open%20ports%202.png "Отображение приветствия от nginx")
- После перенаправления трафика с порта нашего "сервера" на порт контейнера, мы можем без проблем зайти в него и увидеть приветствие от nginx.

Существуют случаи, когда есть несколько контейнеров с разным содержанием, но порт у них один. Решение для докера крайне простое - пробросить другие порты на нужный вам.

Например, вам нужно пробросить порты на 2 разных nginx контейнера с портом 80:
> **`docker run -p 80:80 nginx`** - таким можно сделать 1-й контейнер.
>
> **`docker run -p 8080:80 nginx`** - а таким можно сделать 2-й контейнер.

Переходя по адресу **server_ip** вы попадёте в 1-й контейнер, а по адресу **server_ip:8080** вы попадёте во 2-й контейнер.

Вводить каждый раз порты не удобно? Да, но это уже задача **прокси-сервера** и **DNS**, поэтому мы не будем рассматривать решение этой проблемы.

Для того, чтобы узнать какой порт куда пробрасывать, нужно чистать описание образа на **Docker Hub**, зачастую там всё указано.

## Глава 3. Переменные окружения docker.

- **`docker run -e key=value image_name`** - создаёт контейнер с добавлением переменной **key** и значением **vlaue**.
- Количество переменных так же можно вводить столько раз, сколько раз вы указали флаг **-e**.

Переменные могут быть использованы чем угодно, например, базами данных. Таким образом можно задать пароль для БД или переменные, необходимые для работы какой-либо программы.

Обычно все необходимые для корректной работы переменные так же указаны на странице образа в **Docker Hub**.

## Глава 4. Постоянные данные - docker volumes.

- По умолчанию все данные внутри контейнера хранятся исключительно в контейнере и полностью теряются при его удалении.
- Для сохранения данных локально на сервер необходимо смонтировать директорию/диск на сервере с докер контейнером, для этого существует 3 способа:

1. ***Host volumes***: **`docker run -v /path/to/server_directory:/path/to/container_directory image_name`**. При таком монтировании мы чётко указываем пути по которым будут сохраняться данных из контейнера. То есть данные контейнера из **/path/to/container_directory** будут смонтированы и сохранены в директории сервера - **/path/to/server_directory**.
2. ***Anonymous volumes***: **`docker run -v /path/to/container_directory`**. При таком монтировании на стороне сервера будет создана директория **/var/lib/docker/volumes/HASH/_data**, которая будет смонтирована с директорией контейнера - **/path/to/container_directory**. В данном случае, все сохраняющиеся данные будут хранится в виде хэша. Так же стоит упомянуть, что ***анонимный том самоуничтожается после удаления связанного с ним контейнера***.
3. ***Named volumes***: **`docker run -v directory_name:/path/to/container_directory`**. При использовании этого способа, на стороне сервера создастся директория **directory_name** в каталоге **/var/lib/docker/volumes/**, к которой будет смонтирована директория контейнера - **/path/to/container_directory**

- **`docker volume ls`** - позволяет просмотреть все существующие тома докера.
- **`docker volume create volume_name`** - создаёт том докера.
- **`docker inspect volume_name`** - посмотреть содержимое тома докера. (Выдаст данные в формате **JSON**).

- Докер позволяет монтировать столько томов, сколько нужно и любыми способами сразу.
- Так же можно монтировать одни и те же тома к разным контейнерам.

**А сколько вообще места у томов докера и можно ли их увеличить?**

По умолчанию тома докера ограничены примерно 10-ю гигабайтами параметром **dm.basesize**, которя устанавливается на уровне настроек демона **Docker**.

Так же увеличив значение, его уже нельзя просто так уменьшить. При запуске Docker выдаст ошибку, но если действительно необходимо увеличить размер томов:

> **`sudo dockerd --storage-opt dm.basesize=40G`**.

После этого потребуется перезапустить демон.

Если вам нужно вручную очистить содержимое всех томов, придётся удалять каталог, предварительно остановив демон:

> **`sudo service docker stop`**.
>
> **`sudo rm -rf /var/lib/docker`**.